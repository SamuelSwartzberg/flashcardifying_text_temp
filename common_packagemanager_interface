A dependency is a piece of software another piece of software relies on.

In general, a toolchain is a set of software tools used to do something.
In software development, a toolchain is a set of tools used in combination to develop and deploy software.
A bundler is a tool that merges together all your JavaScript code and its dependencies into one js file, most commonly known as bundle.js
Build tools are the tools that create an executable application from source code.
A bundler is sorta indistinguishable from a build tool.
A task runner is used to run predefined tasks, which would otherwise be tedious or impossible.
Most commonly, the CLI for a framework will also be a build tool.
A package manager is a program that manages packages, i.e. handles installing, uninstalling, updating...
A package manager typically can manage packages from many different developers.
A package is a file in a package format.
A package unsually is made up of an archive (format) of some kind and some metadata.

In latex the package manager is part of the tex distribution
The two most common latex distributions are {{c1::TeX Live}} and {{c1::MiKTeX}}
Anaconda is a batteries-included distribution of Python and R and a bunch of associated packages for scientific computing.

## contaienrs

Containerization isolates software from the rest of the environment it lives in, allowing interaction only through limited, specified channels.
A container often also includes software's dependencies within the container.
An application being contained in a container is said to be containerized.
Containerization improves security and portability.
Containerization is the standard for most mobile operating systems.
Containerization may limit functionality and increase size (since dependencies cannot be shared)

## package managers

cargo is the package manager and build tool for rust.
the official package repository for cargo is crates.io
There is no official task runner for rust, but one commonly used is cargo-make.
npm is the most common package manager for JS, followed by yarn. 
The official package hub for npm is the npm Registry.
npm scripts works as a task runner for JS.
There are more JS build tools than you can shake a stick at. The most common is webpack.
pip is the package manager for python.
The official package hub for pip is PyPI.
apt is the package manager for Ubuntu.
dpkg is a package manager for .deb packages, but does not have a package repository, instead requiring you to download your packages yourself.
apt uses dpkg in the background.
homebrew (command: brew) and macports (command: port) are package managers for macos.
homebrew can also be used on linux, and is written in ruby.
ruby has two package managers, bundler, which mostly does dependency management, and RubyGems with the command gem which mostly does installation.
In ruby, packages are called gems.
The official package hub for RubyGems is rubygems.org
tlmgr is the package manager for tex if you are using the TeX Live distro.
The official package hub for tex is CTAN.
conda is the package manager for the anaconda software distribution.
metro is the bundler for React Native.
snap is the package manager for snaps, which are mainly used in Ubuntu, but can be used on many *nixlikes.
snap packages = snaps
snaps are containerized
snaps are maintained by the snapd daemon.
snap calls its updates refreshes.
snap auto-refreshes four times a day by default.

Package manifest

Cargo.toml|cargo
package.json|npm|yarn

package manifest top-level keys
dependencies|specify dependencies|Cargo.toml|package.json
package|general package information|Cargo.toml

package manager functionality 

update|update the package index|apt|brew|DIFFERENT MEANING: bundler, npm
update|update all dependencies/installed packages|bundler|npm
refresh|update all installed packages|snap
exec|execute a script in the current bundle|bundler
upgrade|installs all available updates|apt|brew
install PACKAGE|install a package|apt|brew|npm|DIFFERENT MEANING: bundler
install|install all dependencies in package manifest|bundler|gem
uninstall PACKAGE|uninstall a package|brew|npm
remove PACKAGE|uninstall a package|apt
ls/list|list installed packages|brew|npm
outdated|show a list of outdated packages|brew|npm|bundler
init|set up a new project/package, incl pacakge manifest|bundler|cargo|npm
show FOO|shows information about a package foo (npm); shows path to gem foo (bundle)
show FOO version|show latest version of package foo|npm
pack|create a tarball of a project/package|npm
publish|publish to offical pagckage hub/repository|cargo|npm
-g or --g|do whatever globally

tap TAPNAME|add a repository|brew

Package managers mainly for programming languages tend to do their package management for the local project by default, and only globally for the whole system if explicityly instructed

A package manifest (though different languages call it different things) specifies metadata and config for your package/project as well as dependencies.
In most package managers, besides the place where you specify your dependencies, there is also a lockfile.
While the package manifest or wherever is where you specify the versions of your dependencies you accept, the lockfile specifies the versions which are actually installed.
package-lock.json|npm
Gemfile.lock|bundler

bundler is kinda weird, since it is a ruby gem itself.
bundler manages the gemfile 
The gemfile contains dependencies
the gemfile is just a ruby file
In a gemfile, the first thing is a call to source, which establishes the global source
source is also a method which takes an url as the first and a block as the second argument if you want to establish additional sources
within the gemfile, gem dependencies are defined by `gem <name>, <version>`




interact with nextjs|next
interact with jekyll|jekyll

## build tool functionality 

build builds a production build in cargo, jekyll, next
test runs unit tests in cargo
doc builds the packages documentation in cargo
clean remove generated files in cargo, jekyll
lint runs the relevant linter on the project (Nextjs: eslint)
new foo creates a new project foo in cargo, jekyll

Hot reloading reloads a thing as you change the code etc.
serve (for jekyll and webpack) and dev (for nextjs) serve your build with hot reloading 
nextjs serves your app at port 3000 by default
You can run a build you created with build (for nextjs) with start (for nextjs)

Most of the config for frameworks is done in a global config file, which is placed in the project root.
_config.yml/.toml|Jekyll